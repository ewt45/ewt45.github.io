import{_ as r,c as l,a as n,d as o,e as t,b as i,r as a,o as p}from"./app-lSJJfXGm.js";const d="/assets/1-CnQkRWCW.png",u="/assets/2-jCDTyuNw.png",c="/assets/3-bveSct5w.png",g="/assets/4-eP9tkoTd.gif",v={},m={class:"custom-container tip"},f={href:"https://github.com/ewt45/edifier-h180plus-typec-samsung",target:"_blank",rel:"noopener noreferrer"},b={href:"https://bbs-pc.edifier.com/post/34341",target:"_blank",rel:"noopener noreferrer"},h={href:"https://developer.android.com/develop/connectivity/usb/host?hl=zh-cn#discovering-d",target:"_blank",rel:"noopener noreferrer"},k={href:"https://developer.android.com/develop/background-work/background-tasks?hl=zh-cn#event-driven",target:"_blank",rel:"noopener noreferrer"},S={href:"https://developer.android.com/develop/background-work/services/fgs/launch?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},x={href:"https://developer.android.com/develop/background-work/services/fgs/restrictions-bg-start?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},T={href:"https://developer.android.com/develop/ui/views/notifications/channels?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},C={href:"https://developer.android.com/develop/connectivity/usb/host?hl=zh-cn#discovering-d",target:"_blank",rel:"noopener noreferrer"},E={href:"https://developer.android.com/develop/background-work/services/fgs/restrictions-bg-start?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},y={href:"https://developer.android.com/develop/ui/views/notifications/channels?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"},I={href:"https://developer.android.google.cn/develop/ui/views/notifications/notification-permission?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"};function N(w,e){const s=a("ExternalLinkIcon");return p(),l("div",null,[n("div",m,[e[4]||(e[4]=o('<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p>',2)),n("p",null,[e[1]||(e[1]=t("项目代码：")),n("a",f,[e[0]||(e[0]=t("https://github.com/ewt45/edifier-h180plus-typec-samsung")),i(s)]),e[2]||(e[2]=n("br",null,null,-1)),e[3]||(e[3]=t(" 可以在 release 下载编译后的 apk"))])]),e[27]||(e[27]=n("h2",{id:"前言",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前言"},[n("span",null,"前言")])],-1)),e[28]||(e[28]=n("p",null,"想买个typec的有线耳机，结果坑一堆。",-1)),e[29]||(e[29]=n("p",null,"漫步者H180Plus(TypeC)，手机为三星s23 oneui6.1 。插上后表现为：开始播放音频时会有滴滴两声。同一个app暂停再播放，不会再次滴滴，换一个应用则会重新滴滴一次。",-1)),e[30]||(e[30]=n("p",null,[t("搜索发现网上好多人都遇到了这个问题。workaround是下载 "),n("code",null,"edifier connect"),t(" 这个app (google play 上中文名叫漫步者蓝牙连接软件，不是那个EDIFIER ConneX), 然后打开保持后台运行。每次插入耳机时，出现弹窗提示app要连接耳机，点击确认即可。")],-1)),n("p",null,[n("a",b,[e[5]||(e[5]=t("求助，耳机发声前会有滴滴声")),i(s)])]),e[31]||(e[31]=n("p",null,[n("img",{src:d,alt:"alt text"})],-1)),e[32]||(e[32]=n("p",null,"不清楚原理，反正保持app在后台运行就不会出现滴滴声。也没有什么其他的好方法，那就自己写一个app简化一下流程吧。目标：应用体积尽可能小，每次插入耳机时无需手动确认。",-1)),e[33]||(e[33]=n("p",null,"参考",-1)),n("ul",null,[n("li",null,[n("a",h,[e[6]||(e[6]=t("USB 主机概览")),i(s)])]),n("li",null,[n("a",k,[e[7]||(e[7]=t("选择哪种后台工作的api")),i(s)])]),n("li",null,[n("a",S,[e[8]||(e[8]=t("启动前台服务")),i(s)])]),n("li",null,[n("a",x,[e[9]||(e[9]=t("针对从后台启动前台服务的限制")),i(s)])]),n("li",null,[n("a",T,[e[10]||(e[10]=t("创建和管理通知渠道")),i(s)])])]),e[34]||(e[34]=o(`<h2 id="分析-edifier-connect" tabindex="-1"><a class="header-anchor" href="#分析-edifier-connect"><span>分析 Edifier Connect</span></a></h2><p>参考 <code>IntegratedConnector.connect()</code><br> 先用 <code>UsbFindConnector</code> 找到漫步者设备<br> 然后 <code>UsbPermissionConnector</code> 检查是否有USB设备权限<br> 然后 <code>UsbConnector</code> 与设备连接<br> 最后用 <code>Sender</code> 发送了一些数据。</p><p>可以通过查看logcat看到具体发送的内容是什么</p><div class="language-logcat line-numbers-mode" data-highlighter="prismjs" data-ext="logcat" data-title="logcat"><pre><code><span class="line">16:57:35.060 dzq-integrated                                   V  send:[aa ec d8 00 00 6e}]main</span>
<span class="line">16:57:35.073                                                  V  recv:[bb ec d8 00 13 00 00 01 00 00 01 00 00 00 01 00 01 00 01 00 00 00 00 00 97]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>顺带一提很多日志都是中文，这app还是国人写的=-=</p><p>可以从日志中看到，向耳机发送数据后，耳机又返回了数据，至于这个返回数据有什么用就不知道了，实际也不用知道，因为后面发现只要与设备连接，不发送这串数据也没有滴滴声。</p><h2 id="编写-app" tabindex="-1"><a class="header-anchor" href="#编写-app"><span>编写 app</span></a></h2><h3 id="usb设备连接" tabindex="-1"><a class="header-anchor" href="#usb设备连接"><span>USB设备连接</span></a></h3>`,8)),n("p",null,[e[12]||(e[12]=t("USB设备的连接断开监听，发送数据等在")),n("a",C,[e[11]||(e[11]=t("USB 主机概览")),i(s)]),e[13]||(e[13]=t("中都介绍的很详细。")),e[14]||(e[14]=n("br",null,null,-1)),e[15]||(e[15]=t(" USB连接有两种，USB配件和USB主机，看起来我们需要看的USB主机的文档。"))]),e[35]||(e[35]=o('<p>连接监听可以写在清单中，为 activity 添加 intent-filter 标签，并附加 meta-data 指定要筛选的设备。<br> 断开监听不能写在清单中，只能在运行时动态注册广播接收器。</p><p>连接后，先获取USB权限（通过 intent-filter 获取到的自动拥有权限）然后通过 <code>usbManager.openDevice()</code> 连接设备，接下来就可以与设备进行通信了。<br> 关闭连接就无法屏蔽滴滴声了，所以不需要关闭连接的代码。</p><h3 id="所需权限" tabindex="-1"><a class="header-anchor" href="#所需权限"><span>所需权限</span></a></h3><p>录音权限</p><p>注意到，连接时的弹窗，有一句“此应用未获取录音权限”（下图左）。而授予录音权限后，这句消失，并且多了一个选项“连接 xxx 设备 后一律打开 xxx app“（下图右）。如果勾选，之后插入usb设备就不会显示弹窗，而是自动打开这个app.</p><p><img src="'+u+'" alt="alt text"></p><p>通知权限</p><p>为保证服务能持续运行，需要发送一个前台通知，因此需要通知权限。</p><p>关闭电池优化</p>',9)),n("p",null,[e[17]||(e[17]=t("目标sdk比较高的话，不允许后台运行的app启动前台服务，")),n("a",E,[e[16]||(e[16]=t("除非关闭了电池优化")),i(s)]),e[18]||(e[18]=t("。另外也可以防止在运行中被杀死。总之开启了比较保险。"))]),e[36]||(e[36]=o('<p>另外，长时间不使用可能导致权限被收回。最好在应用设置界面 - 权限，把对应选项关掉。 <img src="'+c+'" alt="alt text"></p><h3 id="前台服务" tabindex="-1"><a class="header-anchor" href="#前台服务"><span>前台服务</span></a></h3><p>插入耳机后，服务启动与持续运行的逻辑是这样的：</p><ol><li>创建一个过渡 Activity, 在清单中为其添加 intent-filter 接收 USB 设备的连接监听。</li><li>耳机插入时，过渡 Activity 被调起，在 onCreate 中执行 startForegroundService 启动前台服务，然后直接 finish 结束自身。注意自身 intent 包含了 UsbDevice 的信息，所以需要将自身 intent 存入启动 Service 的 intent 的 extra 中。</li><li>Service <ul><li>在 onCreate 中注册广播接收器，监听设备的断开。</li><li>在 onStartCommand 中 取出 intent, 获取 UsbDevice 并尝试连接。如果执行成功，执行 startForeground 发送前台通知。</li></ul></li><li>耳机接入期间，服务一直运行（理想情况下）。</li><li>如果接收到了设备断开的广播，首先确认是否是目标设备，然后 stopService 结束服务。</li></ol><p>由于我将 app 的目标 SDK 设置为了安卓 16, 所以对于前台服务的启动要求比较严格。</p>',5)),n("ul",null,[e[26]||(e[26]=o(`<li>清单中 service 标签必须要指定 foregroundServiceType 属性。这里我设置为 <code>android:foregroundServiceType=&quot;connectedDevice&quot;</code>。</li><li>清单中必须声明前台服务权限，以及对应具体的前台服务类型权限<div class="language-xml line-numbers-mode" data-highlighter="prismjs" data-ext="xml" data-title="xml"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>android.permission.FOREGROUND_SERVICE<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>在 activity 中启动前台服务时，执行 <code>startForegroundService</code> 而非 <code>startService</code>。然后 Service 必须在短时间内执行 <code>startForeground</code> 显示通知，否则系统会抛出异常 ForegroundServiceDidNotStartInTimeException</li><li>startForeground 中必须指定 foregroundServiceType，需要与清单中声明的对应，否则会报错。我这里用 <code>ServiceInfo.FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE</code>。</li>`,4)),n("li",null,[e[20]||(e[20]=t("发送通知需要先创建")),n("a",y,[e[19]||(e[19]=t("通知渠道")),i(s)]),e[21]||(e[21]=t("。这部分我交给ai写的，结果不知道为什么明明是前台服务但通知也能被划掉。"))]),n("li",null,[e[23]||(e[23]=t("目标sdk 安卓13开始，需要在清单中")),n("a",I,[e[22]||(e[22]=t("声明通知权限")),i(s)]),e[24]||(e[24]=t()),e[25]||(e[25]=n("code",null,'<uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>',-1))])]),e[37]||(e[37]=o('<p>过渡 Activity 的其他注意事项</p><ul><li>它的作用是调起 Service 然后结束运行，将其主题修改为透明，这样在视觉上不会打扰用户（实际上会占用0.几秒屏幕，所以还是会小小打扰一下）。</li><li>在清单中为其声明 android:excludeFromRecents=&quot;true&quot; 和 android:noHistory=&quot;true&quot;，这样不会出现在最近应用中。</li><li>还需要声明 android:taskAffinity=&quot;&quot; 否则和主 activity 一个 affinity, 启动并退出后，如果主 activity 存在就会被带起来。</li></ul><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><p>缩小 apk 构建体积，在 gradle 中添加 <code>isMinifyEnabled = true</code> 和 <code>isShrinkResources = true</code> 就行了。构建出 apk 体积 1M.</p><p>中途发现多次拔插会导致系统卡死，几十秒后自动重启（也可手动强制重启）。改了一大堆东西，也不知道哪些有效了。反正最后排查出来一个确定的是，service.onStartCommand 中如果 startForeground 无条件执行，插上就会卡死；如果仅在没有问题（不 stopSelf）的情况下 startForeground 就一切正常。</p><p>关闭电池优化，有个需要声明权限才能发送的 <code>Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS</code>, 我改用不需要权限的 <code>Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS</code> 了。不过去应用设置 - 电池 改成 “不受限制” 也是一样的。 注意第一个 action 需要附带包名作为 uri data, 第二个 action 附带了包名反而无法启动。通过 MT 的 activity 记录 发现第二个 action 调起的 activity 为 <code>com.android.settings.Settings$HighPowerApplicationsActivity</code>，手动通过 ComponentName 启动这个 activity 也行。</p><p>安卓13的通知权限，可以通过 <code>Manifest.permission.POST_NOTIFICATIONS</code> 申请权限，然后直接出现底部弹窗，不需要跳转到设置页面。</p><h2 id="最终效果" tabindex="-1"><a class="header-anchor" href="#最终效果"><span>最终效果</span></a></h2><p>耳机插上后自动显示通知，播放音频没有滴滴声。拔出后通知关闭。</p><p><img src="'+g+'" alt="alt text"></p><h2 id="待完善" tabindex="-1"><a class="header-anchor" href="#待完善"><span>待完善</span></a></h2><ul><li>由于默认都有USB通信权限，就没写申请USB权限的代码了。另一部分原因就是之前系统卡死也与申请权限有些神秘的联系。</li><li>通知抽屉里的通知图标，主体图片很小，然后周围一大圈白色背景，改了半天没改明白。Shizuku就都是蓝色的，以后有时间可以研究研究怎么改图标背景色。</li></ul>',12))])}const O=r(v,[["render",N],["__file","index.html.vue"]]),B=JSON.parse('{"path":"/blogs/2025/09/20-edifier-h180plus-samsung/","title":"解决漫步者H180Plus(TypeC)耳机连接三星手机后每次播放音频出现滴滴声","lang":"zh-CN","frontmatter":{"date":"2025-09-20 08:51","title":"解决漫步者H180Plus(TypeC)耳机连接三星手机后每次播放音频出现滴滴声","categories":["应用"],"tags":["三星","edifier","UsbDevice"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"分析 Edifier Connect","slug":"分析-edifier-connect","link":"#分析-edifier-connect","children":[]},{"level":2,"title":"编写 app","slug":"编写-app","link":"#编写-app","children":[{"level":3,"title":"USB设备连接","slug":"usb设备连接","link":"#usb设备连接","children":[]},{"level":3,"title":"所需权限","slug":"所需权限","link":"#所需权限","children":[]},{"level":3,"title":"前台服务","slug":"前台服务","link":"#前台服务","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"最终效果","slug":"最终效果","link":"#最终效果","children":[]},{"level":2,"title":"待完善","slug":"待完善","link":"#待完善","children":[]}],"git":{"createdTime":1758342455000,"updatedTime":1758343181000,"contributors":[{"name":"ewt45","email":"79033456+ewt45@users.noreply.github.com","commits":2}]},"filePathRelative":"blogs/2025/09/20-edifier-h180plus-samsung/index.md"}');export{O as comp,B as data};
